// Generated by LiveScript 1.5.0
/**
 * @package   Ronion
 * @author    Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @copyright Copyright (c) 2017, Nazar Mokrynskyi
 * @license   MIT License, see license.txt
 */
(function(){
  var crypto, lib, randombytes, test, KEY_LENGTH, MAC_LENGTH, encrypt_iv, wrap_iv, nodes, i$, len$;
  crypto = require('crypto');
  lib = require('..');
  randombytes = crypto.randomBytes;
  test = require('tape');
  KEY_LENGTH = 32;
  MAC_LENGTH = 16;
  encrypt_iv = {};
  wrap_iv = {};
  function encrypt(plaintext, key){
    var iv, cipher, ciphertext, mac, x$, encrypted;
    iv = randombytes(16);
    encrypt_iv[key.join('')] = iv;
    cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
    ciphertext = cipher.update(plaintext);
    cipher.final();
    mac = cipher.getAuthTag();
    x$ = encrypted = new Uint8Array(ciphertext.length + mac.length);
    x$.set(ciphertext);
    x$.set(mac, ciphertext.length);
    return Promise.resolve(encrypted);
  }
  function decrypt(encrypted, key){
    var iv, decipher, ciphertext, mac, plaintext, e;
    iv = encrypt_iv[key.join('')];
    try {
      decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
      ciphertext = encrypted.subarray(0, encrypted.length - MAC_LENGTH);
      mac = encrypted.subarray(encrypted.length - MAC_LENGTH);
      decipher.setAuthTag(mac);
      plaintext = decipher.update(ciphertext);
      decipher.final();
    } catch (e$) {
      e = e$;
      return Promise.reject();
    }
    delete encrypt_iv[key.join('')];
    return Promise.resolve(plaintext);
  }
  function wrap(plaintext, key){
    var iv, cipher, ciphertext;
    iv = randombytes(16);
    wrap_iv[key.join('')] = iv;
    cipher = crypto.createCipheriv('aes-256-ctr', key, iv);
    ciphertext = cipher.update(plaintext);
    cipher.final();
    return Promise.resolve(ciphertext);
  }
  function unwrap(ciphertext, key){
    var iv, decipher, plaintext;
    iv = wrap_iv[key.join('')];
    delete wrap_iv[key.join('')];
    decipher = crypto.createDecipheriv('aes-256-ctr', key, iv);
    plaintext = decipher.update(ciphertext);
    decipher.final();
    return Promise.resolve(plaintext);
  }
  function compute_source_id(address, segment_id){
    return address.join(',') + segment_id.join(',');
  }
  nodes = [new lib(1, 512, 1, MAC_LENGTH), new lib(1, 512, 1, MAC_LENGTH), new lib(1, 512, 1, MAC_LENGTH), new lib(1, 512, 1, MAC_LENGTH)];
  for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
    (fn$.call(this, i$, nodes[i$]));
  }
  test('Ronion', function(t){
    var node_0, node_1, node_2, node_3, key, segment_id, source_id;
    t.plan(24);
    node_0 = nodes[0];
    node_1 = nodes[1];
    node_2 = nodes[2];
    node_3 = nodes[3];
    t.equal(node_0.get_max_command_data_length(), 490, 'Max command data length computed correctly');
    node_1.once('create_request', function(arg$, arg1$, command_data){
      t.equal(command_data.join(''), key.join(''), 'Create request works');
    });
    node_0.once('create_response', function(arg$, arg1$, command_data){
      var source_id_0, source_id_1, key, source_id;
      t.equal(command_data.length, KEY_LENGTH, 'Create response works');
      source_id_0 = compute_source_id(node_0._address, segment_id);
      source_id_1 = compute_source_id(node_1._address, node_1._in_segment_id);
      t.equal(node_0[source_id_1]._local_encryption_key.join(''), node_1[source_id_0]._remote_encryption_key.join(''), 'Encryption keys established #1');
      t.equal(node_1[source_id_0]._local_encryption_key.join(''), node_0[source_id_1]._remote_encryption_key.join(''), 'Encryption keys established #2');
      node_2.once('create_request', function(arg$, arg1$, command_data){
        t.equal(command_data.join(''), key.join(''), 'Extend request works and create request was called #1');
      });
      node_0.once('extend_response', function(arg$, arg1$, command_data){
        var source_id_0, source_id_2, key, source_id;
        t.equal(command_data.length, KEY_LENGTH, 'Extend response works #1');
        source_id_0 = compute_source_id(node_1._address, segment_id);
        source_id_2 = compute_source_id(node_2._address, node_2._in_segment_id);
        t.equal(node_0[source_id_2]._local_encryption_key.join(''), node_2[source_id_0]._remote_encryption_key.join(''), 'Encryption keys established #3');
        t.equal(node_2[source_id_0]._local_encryption_key.join(''), node_0[source_id_2]._remote_encryption_key.join(''), 'Encryption keys established #4');
        node_3.once('create_request', function(arg$, arg1$, command_data){
          t.equal(command_data.join(''), key.join(''), 'Extend request works and create request was called #2');
        });
        node_0.once('extend_response', function(arg$, arg1$, command_data){
          var source_id_0, source_id_3, data_0_to_1;
          t.equal(command_data.length, KEY_LENGTH, 'Extend response works #2');
          source_id_0 = compute_source_id(node_2._address, segment_id);
          source_id_3 = compute_source_id(node_3._address, node_3._in_segment_id);
          t.equal(node_0[source_id_3]._local_encryption_key.join(''), node_3[source_id_0]._remote_encryption_key.join(''), 'Encryption keys established #5');
          t.equal(node_3[source_id_0]._local_encryption_key.join(''), node_0[source_id_3]._remote_encryption_key.join(''), 'Encryption keys established #6');
          data_0_to_1 = randombytes(30);
          node_1.once('data', function(arg$, arg1$, arg2$, arg3$, command_data){
            var data_0_to_3;
            t.equal(command_data.join(''), data_0_to_1.join(''), 'Command data received fine #1');
            data_0_to_3 = randombytes(30);
            node_3.once('data', function(arg$, arg1$, arg2$, arg3$, command_data){
              var data_1_to_0;
              t.equal(command_data.join(''), data_0_to_3.join(''), 'Command data received fine #2');
              data_1_to_0 = randombytes(30);
              node_0.once('data', function(arg$, arg1$, arg2$, arg3$, command_data){
                var data_2_to_0;
                t.equal(command_data.join(''), data_1_to_0.join(''), 'Command data received fine #3');
                data_2_to_0 = randombytes(30);
                node_0.once('data', function(arg$, arg1$, arg2$, arg3$, command_data){
                  var source_id;
                  t.equal(command_data.join(''), data_2_to_0.join(''), 'Command data received fine #4');
                  source_id = compute_source_id(node_1._address, segment_id);
                  t.equal(node_0._outgoing_established_segments.size, 1, 'Correct number of outgoing segments on node 0 before destroying');
                  t.equal(node_0._outgoing_established_segments.get(source_id).length, 3, 'Correct route length on node 0 before destroying');
                  t.equal(node_1._incoming_established_segments.size, 1, 'There is incoming segment on node 1 before destroying');
                  t.equal(node_1._segments_forwarding_mapping.size, 2, 'There is forwarding segments mapping on node 1 before destroying');
                  node_0.destroy(node_1._address, segment_id);
                  t.equal(node_0._outgoing_established_segments.size, 0, 'Correct number of outgoing segments on node 0 after destroying');
                  node_1.destroy(node_0._address, node_1._in_segment_id);
                  t.equal(node_1._incoming_established_segments.size, 0, 'Correct number of incoming segments on node 1 after destroying');
                  t.equal(node_1._segments_forwarding_mapping.size, 0, 'Correct number of forwarding mappings on node 1 after destroying');
                });
                node_2.data(node_1._address, node_2._in_segment_id, node_1._address, 0, data_2_to_0);
              });
              node_1.data(node_0._address, segment_id, node_0._address, 0, data_1_to_0);
            });
            node_0.data(node_1._address, segment_id, node_3._address, 0, data_0_to_3);
          });
          node_0.data(node_1._address, segment_id, node_1._address, 0, data_0_to_1);
        });
        key = randombytes(KEY_LENGTH);
        source_id = compute_source_id(node_3._address, segment_id);
        node_0[source_id] = {
          _local_encryption_key: key
        };
        node_0.extend_request(node_1._address, segment_id, node_3._address, key);
      });
      key = randombytes(KEY_LENGTH);
      source_id = compute_source_id(node_2._address, segment_id);
      node_0[source_id] = {
        _local_encryption_key: key
      };
      node_0.extend_request(node_1._address, segment_id, node_2._address, key);
    });
    key = randombytes(KEY_LENGTH);
    segment_id = node_0.create_request(node_1._address, key);
    source_id = compute_source_id(node_1._address, segment_id);
    node_0[source_id] = {
      _local_encryption_key: key
    };
  });
  function fn$(source_address, node){
    node._address = Uint8Array.of(source_address);
    node.on('send', function(address, packet){
      nodes[address[0]].process_packet(node._address, packet);
    });
    node.on('create_request', function(address, segment_id, command_data){
      var source_id;
      if (command_data.length === KEY_LENGTH) {
        node._in_segment_id = segment_id;
        source_id = compute_source_id(address, segment_id);
        node[source_id] = {
          _remote_encryption_key: command_data,
          _local_encryption_key: randombytes(KEY_LENGTH)
        };
        node.create_response(address, segment_id, node[source_id]._local_encryption_key);
        node.confirm_incoming_segment_established(address, segment_id);
      }
    });
    node.on('create_response', function(address, segment_id, command_data){
      var source_id;
      if (command_data.length === KEY_LENGTH) {
        source_id = compute_source_id(address, segment_id);
        node[source_id]._remote_encryption_key = command_data;
        node.confirm_outgoing_segment_established(address, segment_id);
      }
    });
    node.on('extend_response', function(address, segment_id, command_data){
      var source_id, target_address, target_source_id;
      if (command_data.length === KEY_LENGTH) {
        source_id = compute_source_id(address, segment_id);
        target_address = node._pending_extensions.get(source_id);
        target_source_id = compute_source_id(target_address, segment_id);
        node[target_source_id]._remote_encryption_key = command_data;
        node.confirm_extended_path(address, segment_id);
      }
    });
    node.on('destroy', function(address, segment_id){
      var source_id;
      source_id = compute_source_id(address, segment_id);
      delete node[source_id]._remote_encryption_key;
      delete node[source_id]._local_encryption_key;
    });
    node.on('encrypt', function(data){
      var address, segment_id, target_address, plaintext, source_id;
      address = data.address, segment_id = data.segment_id, target_address = data.target_address, plaintext = data.plaintext;
      source_id = compute_source_id(target_address, segment_id);
      return encrypt(plaintext, node[source_id]._remote_encryption_key).then(function(ciphertext){
        data.ciphertext = ciphertext;
      });
    });
    node.on('decrypt', function(data){
      var address, segment_id, target_address, ciphertext, source_id;
      address = data.address, segment_id = data.segment_id, target_address = data.target_address, ciphertext = data.ciphertext;
      source_id = compute_source_id(target_address, segment_id);
      return decrypt(ciphertext, node[source_id]._local_encryption_key).then(function(plaintext){
        data.plaintext = plaintext;
      });
    });
    node.on('wrap', function(data){
      var address, segment_id, target_address, unwrapped, source_id;
      address = data.address, segment_id = data.segment_id, target_address = data.target_address, unwrapped = data.unwrapped;
      source_id = compute_source_id(target_address, segment_id);
      return wrap(unwrapped, node[source_id]._remote_encryption_key).then(function(wrapped){
        data.wrapped = wrapped;
      });
    });
    node.on('unwrap', function(data){
      var address, segment_id, target_address, wrapped, source_id;
      address = data.address, segment_id = data.segment_id, target_address = data.target_address, wrapped = data.wrapped;
      source_id = compute_source_id(target_address, segment_id);
      return unwrap(wrapped, node[source_id]._local_encryption_key).then(function(unwrapped){
        data.unwrapped = unwrapped;
      });
    });
  }
}).call(this);
